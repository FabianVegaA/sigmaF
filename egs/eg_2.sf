let tail = fn l::[a] -> [a] {return l[1,length(l)];}

let init = fn l::[a] -> [a] {return l[0,length(l)-1];}

let last = fn l::[a] -> a {return l[length(l)-1];}

let head = fn l::[a] -> a {return l[0];}

let take = fn l::list, i::int -> list {return l[0,i];}

let rtake = fn l::list, i::int -> list {return l[i,length(l)];}

let irank = fn i::int, f::int -> list {
	if i >= f then {return [i];}
	return [i] + irank(i+1, f);
}

let irank_interval = fn i::int, f::int, j::int -> list {
	if i >= f then {return [f];}
	return [i] + irank_interval(i+j, f, j);
}

let srepeat = fn s::str, n::int -> list {
	if n <= 0 then {return [];}
	if n == 1 then {return [s];}
	return [s] + srepeat(s, n-1);
}

let _snone_ = fn s::str -> str {return s;} -- This does nothing

let _inone_ = fn i::int -> int {return i;} -- This does nothing

let sconcat = fn l::list -> str {
	return foldl(_snone_, "", l);
}

let sconcat_map = fn l::list, f::function -> list {
	return foldl(f, "", l);
}

let map = fn f::function, l::[a] -> [b] {
	if (l==[]) then {return [];}
	
	return [f(l[0])] + map(f, tail(l));
}

let filter = fn c::function, l::[a] -> [a] {
	if (l == []) then {return [];} 

        return if (c(l[0])) then {[l[0]]} else {[]} +  filter(c, tail(l));
}


let foldl = fn f::function, s::a, l::[a] -> a {
        if length(l) == 1 then {
                return s + f(l[0]);
        }
        return foldl(f, s + f(l[0]), tail(l));
}

let reverse = fn l::[a] -> [a] {
	if l == [] then {return [];}
	return last(l) + reverse(init(l));
}

let ituplefy_2 = fn i::a, j::b -> (a,b) {return (i,j);} 

let zip = fn l1::[a], l2::[b] -> [(a,b)] {
	if l1 == last(l1) || l2 == last(l2) then {
		return [ituplefy_2(l1[0], l2[0])];
	}
	return [ituplefy_2(l1[0],l2[0])] + zip(tail(l1),tail(l2));
}

let split = fn l::[a], i::int -> [a] {
	return [take(l,i), rtake(l,i)]
}

let qsort = fn l::[int] -> [int] {

	if (l == []) then {return [];}
	else {
		let p = l[0];
		let xs = tail(l);
		
		let c_lesser = fn q::int -> bool {return (q < p)};
		let c_greater = fn q::int -> bool {return (q >= p)};

		return qsort(filter(c_lesser, xs)) 
			+ [p] 
			+ qsort(filter(c_greater, xs));
	}
}

let sto_list = fn s::str -> [str] {
	return parse(s, "list")
} 


let stairs = fn i::int -> str {
	if i == 1 then {
		return "*\n";
	}
	return stairs(i-1) + sconcat . srepeat("*", i) + "\n";
}

printLn(stairs(10));

let lsum = fn l::[a] -> a {
    if length(l) == 1 then {return l[0];};
    return l[0] + lsum(tail(l));
}




